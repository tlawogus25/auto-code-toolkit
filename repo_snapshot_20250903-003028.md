# Repository snapshot

- Repo path: /Users/simjaehyeon/CodeAutomation/auto-code-toolkit
- Commit: 9ff8909


---

## .github/actions/auto-code/README.md (binary, skipped)


---

## .github/actions/auto-code/action.yml

```yml
name: Auto Code (Toolkit)
description: Reusable composite action to run auto-code toolkit (long-run, self-heal, cost, hybrid)
inputs:
  config-path:
    description: Path to toolkit config json
    required: false
    default: config/toolkit.config.json
  upload-artifacts:
    description: 'Upload .github/auto/* as artifact'
    required: false
    default: 'true'
runs:
  using: "composite"
  steps:
    - name: Setup Node 22
      uses: actions/setup-node@v4
      with:
        node-version: '22'
    - name: Cache npm
      uses: actions/cache@v4
      with:
        path: ~/.npm
        key: npm-${{ runner.os }}-${{ hashFiles('**/package-lock.json', '**/package.json') }}
        restore-keys: |
          npm-${{ runner.os }}-
    - name: Install deps
      shell: bash
      run: |
        npm ci || npm i

    # ✅ Claude/Cursor CLI 자동 설치(없을 때만)
    - name: Install Claude Code CLI (if missing)
      shell: bash
      run: |
        if ! command -v claude >/dev/null 2>&1; then
          echo "Installing Claude Code CLI..."
          curl -fsSL https://docs.anthropic.com/cli/install.sh | bash || (echo "Claude CLI install failed"; exit 1)
          echo "$HOME/.claude/bin" >> $GITHUB_PATH
        fi

    - name: Install Cursor CLI (if missing)
      shell: bash
      run: |
        if ! command -v cursor-agent >/dev/null 2>&1; then
          echo "Installing Cursor CLI..."
          curl -fsS https://cursor.com/install | bash || (echo "Cursor CLI install failed"; exit 1)
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
        fi

    - name: Run Orchestrator
      shell: bash
      env:
        GH_TOKEN: ${{ env.GH_TOKEN }}                 # ✅ 보장
        GITHUB_EVENT_PATH: ${{ github.event_path }}
        TOOLKIT_CONFIG_PATH: ${{ inputs.config-path }}
        OPENAI_API_KEY: ${{ env.OPENAI_API_KEY }}
        GEMINI_API_KEY: ${{ env.GEMINI_API_KEY }}
        ANTHROPIC_API_KEY: ${{ env.ANTHROPIC_API_KEY }}
        CURSOR_API_KEY: ${{ env.CURSOR_API_KEY }}
      run: node packages/core/src/index.mjs

    - name: Upload artifacts
      if: ${{ inputs.upload-artifacts == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: auto-logs
        path: .github/auto/*
        if-no-files-found: ignore

```


---

## .github/workflows/auto-code.yml

```yml
name: auto-code
on:
  issues:
    types: [opened, edited, labeled]
  issue_comment:
    types: [created, edited]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: read

concurrency:
  group: auto-code-${{ github.ref || github.run_id }}
  cancel-in-progress: true

jobs:
  run:
    runs-on: [self-hosted, macOS, ARM64]
    if: >
      (github.event_name == 'issues' &&
       contains(github.event.issue.labels.*.name, 'automation:run') &&
       startsWith(github.event.issue.body, '/auto')) ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.issue.labels.*.name, 'automation:run') &&
       startsWith(github.event.comment.body, '/auto')) ||
      (github.event_name == 'workflow_dispatch')
    steps:
      - name: Checkout (default branch, deep, clean)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch }}
          fetch-depth: 0
          clean: true

      - name: Show HEADs (debug)
        shell: bash
        run: |
          echo "local HEAD=$(git rev-parse HEAD)"
          echo "remote HEAD=$(git ls-remote origin ${{ github.event.repository.default_branch }} | awk '{print $1}')"

      - name: Ensure local bin on PATH
        shell: bash
        run: echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: "Preflight: required files (git object)"
        shell: bash
        run: |
          set -euo pipefail
          files=(
            "packages/core/src/index.mjs"
            "packages/core/src/orchestrator.mjs"
            "packages/core/src/llm/openai.mjs"
            "packages/core/src/llm/gemini.mjs"
          )
          for f in "${files[@]}"; do
            if git show "HEAD:$f" >/dev/null 2>&1; then
              echo "OK (git): $f"
            else
              echo "::error file=$f::missing in commit (git object)"
              exit 1
            fi
          done

      - name: "Preflight: required files (git object)"
        shell: bash
        run: |
          set -euo pipefail
          for f in packages/core/src/index.mjs packages/core/src/orchestrator.mjs packages/core/src/llm/openai.mjs packages/core/src/llm/gemini.mjs; do
            if [ -f "$f" ]; then
              echo "OK (fs): $f"
              ls -l "$f"
              sha256sum "$f" 2>/dev/null || shasum -a 256 "$f"
            else
              echo "::error file=$f::missing on disk (workspace)"
              exit 1
            fi
          done

      - name: Auto Code (Toolkit)
        uses: ./.github/actions/auto-code
        env:
          GH_TOKEN: ${{ github.token }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
        with:
          config-path: config/toolkit.config.json
          upload-artifacts: 'true'

```


---

## .github/workflows/ci.yml 

```yml 
name: ci
on:
  pull_request:
    branches: [ main ]

jobs:
  test_build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
      - name: Cache npm
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: npm-${{ runner.os }}-${{ hashFiles('**/package-lock.json', '**/package.json') }}
          restore-keys: |
            npm-${{ runner.os }}-
      - run: npm ci || npm i
      - run: npm test --if-present
      - run: npm run build --if-present

```


---

## .github/workflows/hybrid-auto-merge.yml

```yml
name: hybrid-auto-merge
on:
  pull_request:
    types: [labeled, synchronize, ready_for_review]

permissions:
  contents: write
  pull-requests: write
  checks: read

env:
  REQUIRED_APPROVALS: "1"

jobs:
  gate_and_enable:
    if: contains(github.event.pull_request.labels.*.name, 'automation:auto-merge')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Load toolkit config
        id: cfg
        run: |
          if [ -f config/toolkit.config.json ]; then
            echo "CFG<<EOF" >> $GITHUB_OUTPUT
            cat config/toolkit.config.json >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "CFG={}" >> $GITHUB_OUTPUT
          fi

      - name: Validate changed files (allowed/forbidden globs)
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const {owner, repo} = context.repo;
            const files = await github.paginate(github.rest.pulls.listFiles, {owner, repo, pull_number: pr.number});
            const cfg = JSON.parse(process.env.CFG || "{}");
            const allowed = (cfg.policy && cfg.policy.allowed_globs) || ["^src/","^app/","^docs/"];
            const forbidden = (cfg.policy && cfg.policy.forbidden_globs) || ["^\\.env", "^secrets/", "^\\.git/"];
            const A = allowed.map(s=>new RegExp(s.replace(/\*\*/g,".*").replace(/\*/g,"[^/]*")));
            const F = forbidden.map(s=>new RegExp(s.replace(/\*\*/g,".*").replace(/\*/g,"[^/]*")));
            function inAllowed(p){ return A.some(r=>r.test(p)); }
            function inForbidden(p){ return F.some(r=>r.test(p)); }
            for (const f of files) {
              if (inForbidden(f.filename)) core.setFailed(`Forbidden path: ${f.filename}`);
              if (!inAllowed(f.filename)) core.setFailed(`Outside allowed globs: ${f.filename}`);
            }
        env:
          CFG: ${{ steps.cfg.outputs.CFG }}

      - name: Ensure PR is not draft
        run: |
          if [ "${{ github.event.pull_request.draft }}" = "true" ]; then
            echo "PR is draft"; exit 1; fi

      - name: Ensure required checks are green
        env: { GH_TOKEN: ${{ github.token }} }
        run: gh pr checks ${{ github.event.pull_request.number }} --required --fail-fast

      - name: Ensure approvals
        env: { GH_TOKEN: ${{ github.token }} }
        run: |
          APPROVALS=$(gh pr view ${{ github.event.pull_request.number }} --json reviews --jq '[.reviews[]|select(.state=="APPROVED")]|length')
          test $APPROVALS -ge $REQUIRED_APPROVALS || (echo "Need at least $REQUIRED_APPROVALS approval(s)"; exit 1)

      - name: Enable auto-merge (squash)
        env: { GH_TOKEN: ${{ github.token }} }
        run: gh pr merge ${{ github.event.pull_request.number }} --auto --squash

```


---

## .github/workflows/post-merge-continue.yml

```yml
name: post-merge-continue
on:
  pull_request:
    types: [closed]

permissions:
  contents: read
  pull-requests: read
  issues: write

jobs:
  continue:
    if: ${{ github.event.pull_request.merged == true && contains(github.event.pull_request.labels.*.name, 'automation:continue') }}
    runs-on: ubuntu-latest
    steps:
      # PR 코멘트/본문에서 직전 프롬프트를 찾아 후속 이슈를 생성합니다.
      - name: Create follow-up issue with previous prompt context
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;

            // 1) PR 코멘트 전부 조회
            const comments = await github.paginate(
              github.rest.issues.listComments,
              { owner, repo, issue_number: pr.number, per_page: 100 }
            );

            // 2) 우리가 남긴 프롬프트 코멘트 찾기(오케스트레이터 포맷 탐색)
            //    - "# Original Prompt" 또는 "## Last Agent Prompt" 헤더를 단서로 사용
            let promptBlock = null;
            for (const c of comments.reverse()) {
              const body = c.body || "";
              if (body.includes("# Original Prompt") || body.includes("## Last Agent Prompt")) {
                promptBlock = body;
                break;
              }
            }

            // 3) 코멘트가 없으면 PR 본문에서 대체(오케스트레이터가 "## Prompt (truncated)"를 넣음)
            if (!promptBlock) {
              const body = pr.body || "";
              if (body.includes("## Prompt")) {
                promptBlock = body;
              }
            }

            // 4) 그래도 없으면 안내 문구로 대체
            if (!promptBlock) {
              promptBlock = "_No previous prompt could be retrieved from PR comments/body._";
            }

            // 5) 너무 길면 안전하게 자르기(이슈 본문 한도 대비 여유)
            const MAX = 55000;
            if (promptBlock.length > MAX) {
              promptBlock = promptBlock.slice(0, MAX) + "\n\n_(truncated)_";
            }

            // 6) 후속 이슈 본문 템플릿
            const template = [
              "/auto edit long diagnose autorepair test-build lint-fix cooldown-15s time-120m steps-2",
              "이전 PR의 작업을 이어서 다음 우선순위를 진행합니다.",
              "- 실패/미흡 테스트 보완",
              "- 경량 e2e 1~2개 추가(가능 시)",
              "- README 보강",
              "",
              "[Context from previous run]",
              "",
              promptBlock
            ].join("\n");

            // 7) 이슈 생성 (필수 라벨 부여)
            const title = `Continue: follow-up tasks after PR #${pr.number}`;
            const issue = await github.rest.issues.create({
              owner, repo,
              title,
              body: template,
              labels: ["automation:run"]
            });

            core.info(`Opened issue #${issue.data.number} for follow-up.`);

```


---

## .gitignore

```gitignore
actions-runner/

```


---

## README.md

```md
# Auto Code Toolkit (Long-run + Self-heal + Cost + Hybrid Merge)

이 툴킷은 GitHub 이슈/댓글의 `/auto` 프롬프트로:
- LLM(OpenAI/Gemini) → 에이전트(Claude Code/Cursor) 명령 프롬프트 생성
- 에이전트가 코드 패치/생성 → 브랜치 푸시 → **PR 생성**
- **장시간 루프(long)**, **자가 치유(Self-heal)**, **비용/요율(Cost)** 제어
- **혼합 머지(Hybrid Merge)**: PR에서 **커밋 누적** + 조건 충족 시 **Auto-merge 켜기**, 머지 후 **다음 작업 자동 이슈** 생성

## 자동화 동작 과정
1. **트리거**: `/auto` + 라벨 `automation:run`
2. **오케스트레이션**: 모델/에이전트 선택 → (옵션) 장시간 반복 → 체크포인트 커밋
3. **Self-heal**: test/build/lint 실패 로그를 다음 스텝 프롬프트에 자동 삽입
4. **Cost**: `budget-tokens-*`/`cooldown-*s`로 비용/속도 제어
5. **PR 생성 + 혼합 머지**: `auto-merge-when-green`/`continue-after-merge` 토큰으로 자동화

## 필수 사전 준비
- Secrets: `OPENAI_API_KEY`, `GEMINI_API_KEY`, `ANTHROPIC_API_KEY`, `CURSOR_API_KEY`
- 브랜치 보호: Required checks(`build`, `test`, 필요 시 `e2e`)
- 라벨: `automation:run`, (옵션) `automation:auto-merge`, `automation:continue`, …
- **중요**: PR에 “필수 체크” 상태를 만들려면 **`.github/workflows/ci.yml`가 필요**합니다. (본 리포 포함)

## 사용 예시(실전)
# auto-code-toolkit

```


---

## config/toolkit.config.json

```json
{
  "labels": {
    "run": "automation:run",
    "highCost": "automation:high-cost"
  },
  "plugins": [
<<<<<<< HEAD
    "./packages/plugins/basic-tokens",
    "./packages/plugins/crawl",
    "./packages/plugins/self-heal",
    "./packages/plugins/cost",
    "./packages/plugins/hybrid-merge"
=======
    ".packages/plugins/basic-tokens",
    ".packages/plugins/crawl",
    ".packages/plugins/self-heal",
    ".packages/plugins/cost",
    ".packages/plugins/hybrid-merge"
>>>>>>> d2768c6 (fix(config): use relative plugin paths (./packages/…))
  ],
  "tools": {
    "openai": {
      "default": "gpt-4o-mini",
      "heavy": "gpt-4o",
      "max_output_tokens": 16000
    },
    "gemini": {
      "default": "gemini-2.5-flash",
      "heavy": "gemini-2.5-pro"
    },
    "claude": {
      "cli": "claude",
      "permission_mode": "acceptEdits",
      "allowed_tools": [
        "Read",
        "Bash"
      ]
    },
    "cursor": {
      "cli": "cursor-agent",
      "force": true
    }
  },
  "policy": {
    "forbidden_globs": [
      ".env*",
      "secrets/**",
      ".git/**"
    ],
    "allowed_globs": [
      "src/**",
      "app/**",
      "docs/**"
    ],
    "plan_only_threshold_chars": 8000,
    "hard_stop_chars_without_high_cost_label": 20000
  },
  "pipeline": {
    "commands": {
      "lint_fix": "npm run lint --if-present || true",
      "test": "npm test --if-present",
      "build": "npm run build --if-present"
    }
  },
  "providers": {
    "anthropic": {
      "plan": "free"
    },
    "cursor": {
      "plan": "free"
    }
  }
}

```


---

## config/toolkit.config.json

```json
{
  "labels": {
    "run": "automation:run",
    "highCost": "automation:high-cost"
  },
  "plugins": [
<<<<<<< HEAD
    "./packages/plugins/basic-tokens",
    "./packages/plugins/crawl",
    "./packages/plugins/self-heal",
    "./packages/plugins/cost",
    "./packages/plugins/hybrid-merge"
=======
    ".packages/plugins/basic-tokens",
    ".packages/plugins/crawl",
    ".packages/plugins/self-heal",
    ".packages/plugins/cost",
    ".packages/plugins/hybrid-merge"
>>>>>>> d2768c6 (fix(config): use relative plugin paths (./packages/…))
  ],
  "tools": {
    "openai": {
      "default": "gpt-4o-mini",
      "heavy": "gpt-4o",
      "max_output_tokens": 16000
    },
    "gemini": {
      "default": "gemini-2.5-flash",
      "heavy": "gemini-2.5-pro"
    },
    "claude": {
      "cli": "claude",
      "permission_mode": "acceptEdits",
      "allowed_tools": [
        "Read",
        "Bash"
      ]
    },
    "cursor": {
      "cli": "cursor-agent",
      "force": true
    }
  },
  "policy": {
    "forbidden_globs": [
      ".env*",
      "secrets/**",
      ".git/**"
    ],
    "allowed_globs": [
      "src/**",
      "app/**",
      "docs/**"
    ],
    "plan_only_threshold_chars": 8000,
    "hard_stop_chars_without_high_cost_label": 20000
  },
  "pipeline": {
    "commands": {
      "lint_fix": "npm run lint --if-present || true",
      "test": "npm test --if-present",
      "build": "npm run build --if-present"
    }
  },
  "providers": {
    "anthropic": {
      "plan": "free"
    },
    "cursor": {
      "plan": "free"
    }
  }
}

```


---

## config/toolkit.config.json

```json
{
  "labels": {
    "run": "automation:run",
    "highCost": "automation:high-cost"
  },
  "plugins": [
<<<<<<< HEAD
    "./packages/plugins/basic-tokens",
    "./packages/plugins/crawl",
    "./packages/plugins/self-heal",
    "./packages/plugins/cost",
    "./packages/plugins/hybrid-merge"
=======
    ".packages/plugins/basic-tokens",
    ".packages/plugins/crawl",
    ".packages/plugins/self-heal",
    ".packages/plugins/cost",
    ".packages/plugins/hybrid-merge"
>>>>>>> d2768c6 (fix(config): use relative plugin paths (./packages/…))
  ],
  "tools": {
    "openai": {
      "default": "gpt-4o-mini",
      "heavy": "gpt-4o",
      "max_output_tokens": 16000
    },
    "gemini": {
      "default": "gemini-2.5-flash",
      "heavy": "gemini-2.5-pro"
    },
    "claude": {
      "cli": "claude",
      "permission_mode": "acceptEdits",
      "allowed_tools": [
        "Read",
        "Bash"
      ]
    },
    "cursor": {
      "cli": "cursor-agent",
      "force": true
    }
  },
  "policy": {
    "forbidden_globs": [
      ".env*",
      "secrets/**",
      ".git/**"
    ],
    "allowed_globs": [
      "src/**",
      "app/**",
      "docs/**"
    ],
    "plan_only_threshold_chars": 8000,
    "hard_stop_chars_without_high_cost_label": 20000
  },
  "pipeline": {
    "commands": {
      "lint_fix": "npm run lint --if-present || true",
      "test": "npm test --if-present",
      "build": "npm run build --if-present"
    }
  },
  "providers": {
    "anthropic": {
      "plan": "free"
    },
    "cursor": {
      "plan": "free"
    }
  }
}

```


---

## package-lock.json

```json
{
  "name": "auto-code-toolkit",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "auto-code-toolkit",
      "version": "1.0.0",
      "workspaces": [
        "packages/*",
        "packages/plugins/*"
      ]
    },
    "node_modules/@google/genai": {
      "version": "0.13.0",
      "resolved": "https://registry.npmjs.org/@google/genai/-/genai-0.13.0.tgz",
      "integrity": "sha512-eaEncWt875H7046T04mOpxpHJUM+jLIljEf+5QctRyOeChylE/nhpwm1bZWTRWoOu/t46R9r+PmgsJFhTpE7tQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "google-auth-library": "^9.14.2",
        "ws": "^8.18.0",
        "zod": "^3.22.4",
        "zod-to-json-schema": "^3.22.4"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@toolkit/core": {
      "resolved": "packages/core",
      "link": true
    },
    "node_modules/@types/node": {
      "version": "18.19.123",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-18.19.123.tgz",
      "integrity": "sha512-K7DIaHnh0mzVxreCR9qwgNxp3MH9dltPNIEddW9MYUlcKAzm+3grKNSTe2vCJHI1FaLpvpL5JGJrz1UZDKYvDg==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~5.26.4"
      }
    },
    "node_modules/@types/node-fetch": {
      "version": "2.6.13",
      "resolved": "https://registry.npmjs.org/@types/node-fetch/-/node-fetch-2.6.13.tgz",
      "integrity": "sha512-QGpRVpzSaUs30JBSGPjOg4Uveu384erbHBoT1zeONvyCfwQxIkUshLAOqN/k9EjGviPRmWTTe6aH2qySWKTVSw==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*",
        "form-data": "^4.0.4"
      }
    },
    "node_modules/abort-controller": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/abort-controller/-/abort-controller-3.0.0.tgz",
      "integrity": "sha512-h8lQ8tacZYnR3vNQTgibj+tODHI5/+l06Au2Pcriv/Gmet0eaj4TwWH41sO9wnHDiQsEj19q0drzdWdeAHtweg==",
      "license": "MIT",
      "dependencies": {
        "event-target-shim": "^5.0.0"
      },
      "engines": {
        "node": ">=6.5"
      }
    },
    "node_modules/agent-base": {
      "version": "7.1.4",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
      "integrity": "sha512-MnA+YT8fwfJPgBx3m60MNqakm30XOkyIoH1y6huTQvC0PwZG7ki8NacLBcrPbNoo8vEZy7Jpuk7+jMO+CUovTQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/agentkeepalive": {
      "version": "4.6.0",
      "resolved": "https://registry.npmjs.org/agentkeepalive/-/agentkeepalive-4.6.0.tgz",
      "integrity": "sha512-kja8j7PjmncONqaTsB8fQ+wE2mSU2DJ9D4XKoJ5PFWIdRMa6SLSN1ff4mOr4jCbfRSsxR4keIiySJU0N9T5hIQ==",
      "license": "MIT",
      "dependencies": {
        "humanize-ms": "^1.2.1"
      },
      "engines": {
        "node": ">= 8.0.0"
      }
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/base64-js": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
      "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/bignumber.js": {
      "version": "9.3.1",
      "resolved": "https://registry.npmjs.org/bignumber.js/-/bignumber.js-9.3.1.tgz",
      "integrity": "sha512-Ko0uX15oIUS7wJ3Rb30Fs6SkVbLmPBAKdlm7q9+ak9bbIeFf0MwuBsQV6z7+X768/cHsfg+WlysDWJcmthjsjQ==",
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/event-target-shim": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/event-target-shim/-/event-target-shim-5.0.1.tgz",
      "integrity": "sha512-i/2XbnSz/uxRCU6+NdVJgKWDTM427+MqYbkQzD321DuCQJUqOuJKIA0IM2+W2xtYHdKOmZ4dR6fExsd4SXL+WQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/extend": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
      "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==",
      "license": "MIT"
    },
    "node_modules/form-data": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.4.tgz",
      "integrity": "sha512-KrGhL9Q4zjj0kiUt5OO4Mr/A/jlI2jDYs5eHBpYHPcBEVSiipAvn2Ko2HnPe20rmcuuvMHNdZFp+4IlGTMF0Ow==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/form-data-encoder": {
      "version": "1.7.2",
      "resolved": "https://registry.npmjs.org/form-data-encoder/-/form-data-encoder-1.7.2.tgz",
      "integrity": "sha512-qfqtYan3rxrnCk1VYaA4H+Ms9xdpPqvLZa6xmMgFvhO32x7/3J/ExcTd6qpxM0vH2GdMI+poehyBZvqfMTto8A==",
      "license": "MIT"
    },
    "node_modules/formdata-node": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/formdata-node/-/formdata-node-4.4.1.tgz",
      "integrity": "sha512-0iirZp3uVDjVGt9p49aTaqjk84TrglENEDuqfdlZQ1roC9CWlPk6Avf8EEnZNcAqPonwkG35x4n3ww/1THYAeQ==",
      "license": "MIT",
      "dependencies": {
        "node-domexception": "1.0.0",
        "web-streams-polyfill": "4.0.0-beta.3"
      },
      "engines": {
        "node": ">= 12.20"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gaxios": {
      "version": "6.7.1",
      "resolved": "https://registry.npmjs.org/gaxios/-/gaxios-6.7.1.tgz",
      "integrity": "sha512-LDODD4TMYx7XXdpwxAVRAIAuB0bzv0s+ywFonY46k126qzQHT9ygyoa9tncmOiQmmDrik65UYsEkv3lbfqQ3yQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "extend": "^3.0.2",
        "https-proxy-agent": "^7.0.1",
        "is-stream": "^2.0.0",
        "node-fetch": "^2.6.9",
        "uuid": "^9.0.1"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/gcp-metadata": {
      "version": "6.1.1",
      "resolved": "https://registry.npmjs.org/gcp-metadata/-/gcp-metadata-6.1.1.tgz",
      "integrity": "sha512-a4tiq7E0/5fTjxPAaH4jpjkSv/uCaU2p5KC6HVGrvl0cDjA8iBZv4vv1gyzlmK0ZUKqwpOyQMKzZQe3lTit77A==",
      "license": "Apache-2.0",
      "dependencies": {
        "gaxios": "^6.1.1",
        "google-logging-utils": "^0.0.2",
        "json-bigint": "^1.0.0"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/google-auth-library": {
      "version": "9.15.1",
      "resolved": "https://registry.npmjs.org/google-auth-library/-/google-auth-library-9.15.1.tgz",
      "integrity": "sha512-Jb6Z0+nvECVz+2lzSMt9u98UsoakXxA2HGHMCxh+so3n90XgYWkq5dur19JAJV7ONiJY22yBTyJB1TSkvPq9Ng==",
      "license": "Apache-2.0",
      "dependencies": {
        "base64-js": "^1.3.0",
        "ecdsa-sig-formatter": "^1.0.11",
        "gaxios": "^6.1.1",
        "gcp-metadata": "^6.1.0",
        "gtoken": "^7.0.0",
        "jws": "^4.0.0"
      },
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/google-logging-utils": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/google-logging-utils/-/google-logging-utils-0.0.2.tgz",
      "integrity": "sha512-NEgUnEcBiP5HrPzufUkBzJOD/Sxsco3rLNo1F1TNf7ieU8ryUzBhqba8r756CjLX7rn3fHl6iLEwPYuqpoKgQQ==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gtoken": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/gtoken/-/gtoken-7.1.0.tgz",
      "integrity": "sha512-pCcEwRi+TKpMlxAQObHDQ56KawURgyAf6jtIY046fJ5tIv3zDe/LEIubckAO8fj6JnAxLdmWkUfNyulQ2iKdEw==",
      "license": "MIT",
      "dependencies": {
        "gaxios": "^6.0.0",
        "jws": "^4.0.0"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.2",
        "debug": "4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/humanize-ms": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/humanize-ms/-/humanize-ms-1.2.1.tgz",
      "integrity": "sha512-Fl70vYtsAFb/C06PTS9dZBo7ihau+Tu/DNCk/OyHhea07S+aeMWpFFkUaXRa8fI+ScZbEI8dfSxwY7gxZ9SAVQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.0.0"
      }
    },
    "node_modules/is-stream": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz",
      "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/json-bigint": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/json-bigint/-/json-bigint-1.0.0.tgz",
      "integrity": "sha512-SiPv/8VpZuWbvLSMtTDU8hEfrZWg/mH/nV/b4o0CYbSxu1UIQPLdwKOCIyLQX+VIPO5vrLX3i8qtqFyhdPSUSQ==",
      "license": "MIT",
      "dependencies": {
        "bignumber.js": "^9.0.0"
      }
    },
    "node_modules/jwa": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-2.0.1.tgz",
      "integrity": "sha512-hRF04fqJIP8Abbkq5NKGN0Bbr3JxlQ+qhZufXVr0DvujKy93ZCbXZMHDL4EOtodSbCWxOqR8MS1tXA5hwqCXDg==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/jws/-/jws-4.0.0.tgz",
      "integrity": "sha512-KDncfTmOZoOMTFG4mBlG0qUIOlc03fmzH+ru6RgYVZhPkyiy/92Owlt/8UEN+a4TXR1FQetfIpJE8ApdvdVxTg==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^2.0.0",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/node-domexception": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/node-domexception/-/node-domexception-1.0.0.tgz",
      "integrity": "sha512-/jKZoMpw0F8GRwl4/eLROPA3cfcXtLApP0QzLmUT/HuPCZWyB7IY9ZrMeKw2O/nFIqPQB3PVM9aYm0F312AXDQ==",
      "deprecated": "Use your platform's native DOMException instead",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/jimmywarting"
        },
        {
          "type": "github",
          "url": "https://paypal.me/jimmywarting"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=10.5.0"
      }
    },
    "node_modules/node-fetch": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
      "license": "MIT",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/openai": {
      "version": "4.104.0",
      "resolved": "https://registry.npmjs.org/openai/-/openai-4.104.0.tgz",
      "integrity": "sha512-p99EFNsA/yX6UhVO93f5kJsDRLAg+CTA2RBqdHK4RtK8u5IJw32Hyb2dTGKbnnFmnuoBv5r7Z2CURI9sGZpSuA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@types/node": "^18.11.18",
        "@types/node-fetch": "^2.6.4",
        "abort-controller": "^3.0.0",
        "agentkeepalive": "^4.2.1",
        "form-data-encoder": "1.7.2",
        "formdata-node": "^4.3.2",
        "node-fetch": "^2.6.7"
      },
      "bin": {
        "openai": "bin/cli"
      },
      "peerDependencies": {
        "ws": "^8.18.0",
        "zod": "^3.23.8"
      },
      "peerDependenciesMeta": {
        "ws": {
          "optional": true
        },
        "zod": {
          "optional": true
        }
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==",
      "license": "MIT"
    },
    "node_modules/undici-types": {
      "version": "5.26.5",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-5.26.5.tgz",
      "integrity": "sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA==",
      "license": "MIT"
    },
    "node_modules/uuid": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-9.0.1.tgz",
      "integrity": "sha512-b+1eJOlsR9K8HJpow9Ok3fiWOWSIcIzXodvv0rQjVoOVNpWMpxf1wZNpt4y9h10odCNrqnYp1OBzRktckBe3sA==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/web-streams-polyfill": {
      "version": "4.0.0-beta.3",
      "resolved": "https://registry.npmjs.org/web-streams-polyfill/-/web-streams-polyfill-4.0.0-beta.3.tgz",
      "integrity": "sha512-QW95TCTaHmsYfHDybGMwO5IJIM93I/6vTRk+daHTWFPhwh+C8Cg7j7XyKrwrj8Ib6vYXe0ocYNrmzY4xAAN6ug==",
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==",
      "license": "BSD-2-Clause"
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "license": "MIT",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "node_modules/ws": {
      "version": "8.18.3",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/zod": {
      "version": "3.25.76",
      "resolved": "https://registry.npmjs.org/zod/-/zod-3.25.76.tgz",
      "integrity": "sha512-gzUt/qt81nXsFGKIFcC3YnfEAx5NkunCfnDlvuBSSFS02bcXu4Lmea0AFIUwbLWxWPx3d9p8S5QoaujKcNQxcQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    },
    "node_modules/zod-to-json-schema": {
      "version": "3.24.6",
      "resolved": "https://registry.npmjs.org/zod-to-json-schema/-/zod-to-json-schema-3.24.6.tgz",
      "integrity": "sha512-h/z3PKvcTcTetyjl1fkj79MHNEjm+HpD6NXheWjzOekY7kV+lwDYnHw+ivHkijnCSMz1yJaWBD9vu/Fcmk+vEg==",
      "license": "ISC",
      "peerDependencies": {
        "zod": "^3.24.1"
      }
    },
    "packages/core": {
      "name": "@toolkit/core",
      "version": "1.0.0",
      "dependencies": {
        "@google/genai": "^0.13.0",
        "openai": "^4.57.0"
      }
    }
  }
}

```


---

## package.json

```json
{
  "name": "auto-code-toolkit",
  "private": true,
  "version": "1.0.0",
  "workspaces": [
    "packages/*",
    "packages/plugins/*"
  ]
}

```


---

## packages/core/package.json

```json
{
  "name": "@toolkit/core",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.mjs",
  "dependencies": {
    "openai": "^4.57.0",
    "@google/genai": "^0.13.0"
  }
}

```


---

## packages/core/src/agents/claude.mjs

```mjs
import { execSync } from "node:child_process";

export async function runWithClaude(prompt, tools, policy) {
  const cli = tools.claude?.cli || "claude";
  const perm = tools.claude?.permission_mode || "acceptEdits";
  const allowed = (tools.claude?.allowed_tools || ["Read","Bash"]).join(",");
  const cmd = [
    cli,
    "-p", JSON.stringify(prompt),
    "--permission-mode", perm,
    "--allowedTools", `"${allowed}"`,
    "--cwd", ".",
    "--output-format", "text"
  ].join(" ");
  execSync(cmd, { stdio: "inherit" });
}

```


---

## packages/core/src/agents/cursor.mjs

```mjs
import { execSync } from "node:child_process";

export async function runWithCursor(prompt, tools, policy) {
  const cli = tools.cursor?.cli || "cursor-agent";
  const force = tools.cursor?.force ? "--force" : "";
  const cmd = [cli,"-p",JSON.stringify(prompt),force,"--output-format","text"].join(" ");
  execSync(cmd, { stdio: "inherit" });
}

```


---

## packages/core/src/index.mjs

```mjs
import { runOrchestrator } from "./orchestrator.mjs";
const repoRoot = process.cwd();
const eventPath = process.env.GITHUB_EVENT_PATH;
const configPath = process.env.TOOLKIT_CONFIG_PATH || "config/toolkit.config.json";
if (!eventPath) { console.error("GITHUB_EVENT_PATH is required"); process.exit(1); }
runOrchestrator({ repoRoot, configPath, eventPath })
  .then((r) => { console.log("Done:", r); })
  .catch((e) => { console.error(e); process.exit(1); });

```


---

## packages/core/src/llm/gemini.mjs

```mjs
import { GoogleGenAI } from "@google/genai";

export function makeGemini(apiKey) {
  if (!apiKey) throw new Error("GEMINI_API_KEY required");
  return new GoogleGenAI({ apiKey });
}

// Return { text, usage: null }
export async function runGemini({ client, model, user }) {
  const r = await client.models.generateContent({
    model,
    contents: [{ role: "user", parts: [{ text: user }]}]
  });
  return { text: (r.response?.text() || ""), usage: null };
}

```


---

## packages/core/src/llm/openai.mjs

```mjs
import OpenAI from "openai";

export function makeOpenAI(apiKey) {
  if (!apiKey) throw new Error("OPENAI_API_KEY required");
  return new OpenAI({ apiKey });
}

// Return { text, usage }
export async function runOpenAI({ client, model, system, user, reasoning }) {
  const r = await client.responses.create({
    model,
    input: [{ role: "system", content: system }, { role: "user", content: user }],
    ...(reasoning ? { reasoning } : {})
  });
  const usage = r.usage || r.output?.[0]?.usage || null;
  const text = r.output_text || "";
  return { text, usage };
}

```


---

## packages/core/src/orchestrator.mjs

```mjs
// Orchestrator with long-run + self-heal/cost + hybrid-merge support                // 파일 목적: 자동 코딩 오케스트레이션
import { readFileSync, writeFileSync, existsSync } from "node:fs";                  // 파일 읽기/쓰기/존재확인을 위한 node:fs 네임드 임포트
import { execSync } from "node:child_process";                                      // git/gh 명령 실행을 위한 child_process 임포트
import path from "node:path";                                                       // 경로 계산 유틸
import fs from "node:fs";                                                           // mkdirSync 등 동기 FS 유틸
import process from "node:process";                                                 // 환경변수·프로세스 정보 접근
import { loadPlugins } from "./tokens/registry.mjs";                                // 플러그인 로더(토큰/훅 주입)
import { pickLLMAndAgent } from "./router.mjs";                                     // LLM/Agent 라우팅 결정
import { makeOpenAI, runOpenAI } from "./llm/openai.mjs";                           // OpenAI 어댑터
import { makeGemini, runGemini } from "./llm/gemini.mjs";                           // Gemini 어댑터
import { runWithClaude } from "./agents/claude.mjs";                                // Claude 에이전트 실행기
import { runWithCursor } from "./agents/cursor.mjs";                                // Cursor 에이전트 실행기

function nowIso(){ return new Date().toISOString(); }                               // ISO 타임스탬프 헬퍼(로그/기록용)

export async function runOrchestrator({ repoRoot, configPath, eventPath }) {        // 메인 진입점: 리포 루트/설정/이벤트 경로 인자
  const cfg = JSON.parse(readFileSync(path.join(repoRoot, configPath), "utf8"));    // 툴킷 설정 JSON 로드
  const tools = cfg.tools || {};                                                    // 도구 설정(모델/CLI 등)
  const policy = cfg.policy || {};                                                  // 정책(허용/금지 글롭, 길이 한도 등)
  const labelsCfg = cfg.labels || {};                                               // 라벨 키 설정(run/highCost 등)
  const pluginsPaths = cfg.plugins || [];                                           // 플러그인 경로 목록
  const pipeline = cfg.pipeline || { commands: {} };                                // 파이프라인 명령(빌드/테스트 등)

  const evt = JSON.parse(readFileSync(eventPath, "utf8"));                          // GitHub 이벤트 페이로드 로드
  const isIssue = !!evt.issue && !evt.comment;                                      // 이슈인지(코멘트가 아닌지) 판별
  const rawBody = (isIssue ? (evt.issue.body || "") : (evt.comment.body || "")).trim(); // /auto 원문 추출
  const labels = (evt.issue?.labels || []).map(l => l.name || "");                  // 라벨명 배열 추출

  if (!rawBody.startsWith("/auto")) return { skipped: true };                       // /auto 아닌 이벤트는 스킵
  if (!labels.includes(labelsCfg.run || "automation:run")) return { skipped: true };// 필수 라벨 없으면 스킵

  const { tokens, hooks } = await loadPlugins(pluginsPaths, repoRoot);              // 플러그인 로드(토큰 핸들러/훅 획득)
  const after = rawBody.replace(/^\/auto\s*/i, "");                                 // /auto 접두어 제거
  const m = after.match(/^((?:[\w:-]+)\b\s*)+/i) || [""];                           // 토큰 시퀀스(키워드) 매칭
  const seq = (m[0] || "").trim().split(/\s+/).filter(Boolean);                    // 토큰을 공백 분리하여 배열화
  const rest = after.slice((m[0]||"").length).trim();                               // 나머지 본문(자유 프롬프트)

  const ctx = {                                                                     // 실행 컨텍스트(오케스트레이터 상태)
    repoRoot, cfg, tools, policy, labels, pipeline,                                 // 환경/정책/라벨/파이프라인
    tokens: seq, tokenFlags: {},                                                    // 토큰 목록/플래그
    userDemand: rest,                                                                // 사용자 요구(프롬프트)
    llm: null, model: null, agent: null,                                            // 선택된 LLM/모델/에이전트
    agentPrompt: "",                                                                 // 에이전트에 줄 최종 프롬프트
    planOnly: false, preferFast: false,                                             // 플랜 전용/빠른 모델 선호
    longMode: false, budgetMinutes: null, budgetSteps: null,                        // 장시간 모드/예산
    loopSummary: { startedAt: nowIso(), steps: [] },                                // 루프 요약(체크포인트 메타)
    usageTotals: { openai: { input:0, output:0 }, gemini: { input:0, output:0 } },  // 토큰 사용량 누적
    diagnostics: { last: null },                                                    // 최근 진단(에러 등)
    prNumber: null,                                                                  // 생성된 PR 번호
    branch: null                                                                     // 작업 브랜치명
  };

  for (const t of seq) { const h = tokens.get(t.toLowerCase()); if (h) await h(ctx); } // 토큰별 핸들러 실행(옵션/플래그 세팅)

  const highCost = labels.includes(labelsCfg.highCost || "automation:high-cost");  // 고비용 라벨 유무
  const max = policy.hard_stop_chars_without_high_cost_label ?? 20000;             // 라벨 없을 때 입력 최대 길이
  const planThreshold = policy.plan_only_threshold_chars ?? 8000;                  // 플랜 전용 임계치
  if (!(ctx.tokenFlags?.force && highCost)) {                                      // force+고비용이 아니면
    if (ctx.userDemand.length > max && !highCost)                                  // 입력 길이 제한 초과 시
      throw new Error("Input too long without high-cost label.");                  // 즉시 중단(비용 보호)
  }
  ctx.planOnly = ctx.planOnly || (ctx.userDemand.length > planThreshold && !highCost); // 길면 플랜 전용으로 강등

  const route = pickLLMAndAgent({ userDemand: ctx.userDemand, planOnly: ctx.planOnly, tools, preferFast: ctx.preferFast }); // 라우팅 결정
  ctx.llm = route.llm; ctx.model = route.model; ctx.agent = route.agent;          // 선택 결과 저장

  for (const h of hooks.beforeLLM) await h(ctx);                                   // LLM 호출 전 훅 실행

  const systemGuard = [                                                            // 에이전트 가드레일(시스템 프롬프트)
    "[에이전트 가드레일]",
    `- 허용 경로: ${(policy.allowed_globs||["src/**","app/**","docs/**"]).join(", ")}`,
    `- 금지 경로: ${(policy.forbidden_globs||[".env*","secrets/**",".git/**"]).join(", ")}`,
    "- .env* / 비밀키 / .git 은 읽기·쓰기도 금지",
    "- 테스트가 있으면 실행 전략 제안",
    "- 변경은 설명 가능한 작은 커밋 단위 권장"
  ].join("\n");                                                                     // 가드레일 문자열 병합

  const content = [                                                                 // 사용자 요구/산출물 템플릿 결합
    systemGuard, "\n[사용자 요구]", ctx.userDemand, "\n[원하는 산출물]",
    "- 변경 개요(목록)", "- 파일별 수정 계획", "- 안전 체크리스트",
    ctx.planOnly ? "- (플랜 전용: 실행명령 생략)" : "- 최종 실행할 수정 단계"
  ].join("\n");                                                                     // 최종 LLM 입력 본문

  async function genPrompt(){                                                       // LLM 호출 래퍼(모델별 분기)
    if (ctx.llm === "openai") {                                                     // OpenAI 선택 시
      const { text, usage } = await runOpenAI({                                     // OpenAI Responses 호출
        client: makeOpenAI(process.env.OPENAI_API_KEY),                             // 클라이언트 생성(키 필요)
        model: ctx.model, system: systemGuard, user: content,                       // 모델/시스템/유저 입력
        reasoning: { effort: ctx.planOnly ? "medium" : "high" }                     // 추론 노력도 설정
      });                                                                            // 호출 종료
      if (usage) { ctx.usageTotals.openai.input += (usage.input_tokens||0); ctx.usageTotals.openai.output += (usage.output_tokens||0); } // 사용량 누적
      return text;                                                                   // 응답 텍스트 반환
    } else {                                                                         // 그 외(Gemini 등)
      const { text } = await runGemini({ client: makeGemini(process.env.GEMINI_API_KEY), model: ctx.model, user: content }); // Gemini 호출
      return text;                                                                   // 응답 텍스트 반환
    }                                                                                // 분기 끝
  }                                                                                  // 함수 끝

  ctx.agentPrompt = await genPrompt();                                               // 에이전트에 줄 최종 프롬프트 생성
  for (const h of hooks.afterLLM) await h(ctx);                                      // LLM 호출 후 훅 실행

  if (ctx.tokenFlags?.dryRun) return { dryRun: true, ctx };                          // 드라이런 플래그면 여기서 종료
  if (ctx.agent === "none" || ctx.planOnly) return { planOnly: true, ctx };          // 에이전트 없음/플랜 전용이면 종료

  function checkpointCommit(msg){                                                    // 체크포인트 커밋 헬퍼
    try { execSync(`git add -A`, { stdio: "inherit" }); execSync(`git commit -m ${JSON.stringify(msg)}`, { stdio: "inherit" }); } // 변경이 있으면 커밋
    catch { console.log("No changes to commit for checkpoint."); }                   // 변경이 없으면 안내
  }                                                                                  // 함수 끝

  execSync(`git config user.name "github-actions[bot]"`, { stdio: "inherit" });      // 커밋 사용자명 설정
  execSync(`git config user.email "github-actions[bot]@users.noreply.github.com"`, { stdio: "inherit" }); // 커밋 이메일 설정
  const branch = `auto/${Date.now()}`;                                               // 작업 브랜치명(시간 기반)
  ctx.branch = branch;                                                                // 컨텍스트에 저장
  execSync(`git checkout -b ${branch}`, { stdio: "inherit" });                       // 새 브랜치 생성/체크아웃

  // ✅ 출력 디렉터리 보장(핵심 수정): AUTO_OUT_DIR 우선, 없으면 .github/auto 사용                                   // *** 핵심 변경 시작 ***
  const outDir = process.env.AUTO_OUT_DIR                                           // 환경변수 지정 시
    ? path.resolve(process.env.AUTO_OUT_DIR)                                        // 절대 경로로 정규화
    : path.join(repoRoot, ".github", "auto");                                       // 기본값: 리포/.github/auto
  fs.mkdirSync(outDir, { recursive: true });                                        // 상위까지 재귀 생성(ENOENT 방지)
  // ✅ 취소 파일 경로도 동일 outDir 아래로 통일                                                                       // CANCEL 파일 경로 일관화
  const cancelPath = path.join(outDir, "CANCEL");                                   // CANCEL 파일 경로
  const start = Date.now();                                                         // 실행 시작 시각(ms)
  // ✅ 핵심 변경 끝                                                                                                   // *** 핵심 변경 종료 ***

  async function runOneStep(step) {                                                 // 한 단계 실행(에이전트→커밋→푸시)
    for (const h of hooks.beforeAgent) await h(ctx);                                // 에이전트 전 훅
    try {                                                                            // 예외 처리 시작
      if (ctx.agent === "claude") await runWithClaude(ctx.agentPrompt, tools, policy); // Claude 에이전트 실행
      else await runWithCursor(ctx.agentPrompt, tools, policy);                     // Cursor 에이전트 실행
    } catch(e) {                                                                     // 에러 발생 시
      console.log("[Agent error]", e.message);                                      // 에러 메시지 로깅
      ctx.diagnostics.last = { type: "agent-error", message: e.message };           // 진단 정보 보관
    }                                                                                // try/catch 끝
    for (const h of hooks.afterAgent) await h(ctx);                                 // 에이전트 후 훅
    checkpointCommit(`auto: checkpoint step ${step}`);                               // 체크포인트 커밋 시도
    try { execSync(`git push origin ${branch}`, { stdio: "inherit" }); } catch {}   // 브랜치 푸시(실패 무시)
    ctx.loopSummary.steps.push({ step, at: new Date().toISOString() });             // 단계 메타 누적
  }                                                                                  // 함수 끝

  if (ctx.longMode) {                                                                // 장시간 모드 분기
    const maxMs = (ctx.budgetMinutes||60) * 60 * 1000;                               // 시간 예산(ms)
    const maxSteps = ctx.budgetSteps || 3;                                           // 단계 예산(기본 3)
    for (let step=1; step<=maxSteps; step++) {                                       // 단계 루프
      if (existsSync(cancelPath)) break;                                             // CANCEL 파일 있으면 중단
      if ((Date.now()-start) > maxMs) break;                                         // 시간 예산 초과 시 중단
      await runOneStep(step);                                                        // 단계 실행
      if (!ctx.agentPrompt || typeof ctx.agentPrompt !== "string") ctx.agentPrompt = "Continue."; // 프롬프트 보정
    }                                                                                // 루프 끝
  } else {                                                                           // 단발 모드
    await runOneStep(1);                                                             // 1단계만 실행
  }                                                                                  // 분기 끝
  for (const h of hooks.beforePR) await h(ctx);                                      // PR 생성 전 훅 실행

  const tokenList = (ctx.tokens||[]).join(", ") || "(none)";                         // 사용 토큰(키워드) 목록 문자열
  const labelList = labels.join(", ") || "(none)";                                   // 라벨 목록 문자열
  const truncatedUserDemand = ctx.userDemand.slice(0, 2000);                         // 사용자 본문 일부(2k)만 발췌
  const costLine = `OpenAI usage: in=${ctx.usageTotals.openai.input} out=${ctx.usageTotals.openai.output}`; // OpenAI 사용량 표기

  const infoMd = [                                                                    // PR 본문(요약) 마크다운
    `## Auto-run Info`,
    ``,
    `- LLM: **${ctx.llm}** (${ctx.model})`,
    `- Agent: **${ctx.agent}**`,
    `- Branch: ${ctx.branch}`,
    `- Labels: ${labelList}`,
    `- Tokens: ${tokenList}`,
    `- ${costLine}`,
    ``,
    `## Prompt (truncated)`,
    "",
    "```",
    truncatedUserDemand,
    "```",
    "",
    ctx.longMode ? `> Long-run: budget ${ctx.budgetMinutes} min / ${ctx.budgetSteps} steps.` : ""
  ].join("\n");                                                                       // 문자열 결합 완료

  const promptMd = [                                                                  // 전체 프롬프트/마지막 에이전트 입력 기록
    `# Original Prompt`,
    "",
    "```",
    ctx.userDemand,
    "```",
    "",
    "## Last Agent Prompt",
    "",
    "```",
    ctx.agentPrompt,
    "```"
  ].join("\n");                                                                       // 문자열 결합 완료

  // ✅ 디렉터리 보장 후 파일 경로를 outDir 기반으로 생성(핵심 수정 반영)                                            // *** 핵심 저장 경로 ***
  const prBodyPath = path.join(outDir, `pr-body-${Date.now()}.md`);                  // PR 본문 파일 경로
  const promptBodyPath = path.join(outDir, `prompt-${Date.now()}.md`);               // 프롬프트 파일 경로
  writeFileSync(prBodyPath, infoMd, "utf8");                                         // PR 본문 파일 쓰기
  writeFileSync(promptBodyPath, promptMd, "utf8");                                   // 프롬프트 파일 쓰기

  const title = `auto: ${ctx.branch} [${ctx.llm}/${ctx.agent}] (tokens: ${tokenList})`; // PR 제목 생성
  execSync(`gh pr create --title ${JSON.stringify(title)} --body-file ${JSON.stringify(prBodyPath)} --base main --head ${ctx.branch}`, { stdio: "inherit" }); // gh로 PR 생성

  const prNumber = execSync(`gh pr view --json number --head ${ctx.branch} --jq .number`).toString().trim(); // 생성된 PR 번호 조회
  ctx.prNumber = prNumber || null;                                                   // 컨텍스트에 저장(없으면 null)

  if (prNumber) {                                                                    // PR 번호가 있으면
    execSync(`gh pr comment ${prNumber} --body-file ${JSON.stringify(promptBodyPath)}`, { stdio: "inherit" }); // 프롬프트 전문을 코멘트로 추가
  }                                                                                  // 분기 끝

  for (const h of hooks.afterPR) await h(ctx);                                       // PR 생성 후 훅 실행

  return { success: true, branch: ctx.branch, long: ctx.longMode, usage: ctx.usageTotals, prNumber: ctx.prNumber }; // 실행 결과 요약 반환
}                                                                                    // runOrchestrator 끝
```


---

## packages/core/src/router.mjs

```mjs
export function pickLLMAndAgent({ userDemand, planOnly, tools, preferFast = false }) {
  const wantsJSON = /JSON|스키마|schema|structured/i.test(userDemand);
  const long = userDemand.length > 1500 && !preferFast;
  const llm = wantsJSON ? "gemini" : "openai";
  const model = wantsJSON
    ? (long ? tools.gemini.heavy : tools.gemini.default)
    : (long ? tools.openai.heavy : tools.openai.default);
  let agent = "claude";
  if (wantsJSON) agent = "cursor";
  if (planOnly) agent = "none";
  return { llm, model, agent };
}

```


---

## packages/core/src/tokens/registry.mjs

```mjs
/* Part 1/1 — registry.mjs 플러그인 경로 리졸버 추가 (의존성: node:url, node:path, node:fs) */
/* 이 파일의 목적: "packages/plugins/..." 같은 워크스페이스 별칭을 실제 파일 경로(파일 URL)로 변환하여 import()가 동작하도록 보정한다. */
import { fileURLToPath, pathToFileURL } from "node:url";      // ESM 파일 경로 변환 유틸을 불러온다.
import path from "node:path";                                 // 경로 결합/정규화에 사용한다.
import fs from "node:fs";                                     // 파일 존재 여부 점검에 사용한다.

/* __filename/__dirname 대체(ESM 환경): 현재 모듈의 실제 파일 시스템 경로를 구한다. */
const __filename = fileURLToPath(import.meta.url);            // 현재 모듈의 파일 경로를 문자열로 얻는다.
const __dirname  = path.dirname(__filename);                  // 현재 모듈이 위치한 디렉터리 경로를 구한다.

/* 워크스페이스의 packages 디렉터리를 계산한다.
   현재 파일은 packages/core/src/tokens/registry.mjs 라고 가정하므로,
   여기서 ../../.. 를 올라가면 packages 디렉터리에 도달한다. */
const PACKAGES_DIR = path.resolve(__dirname, "..", "..", "..");  // 예: /repo/packages
const PLUGINS_DIR  = process.env.PLUGINS_DIR                    // 환경변수로 오버라이드 가능하게 한다.
  ? path.resolve(process.env.PLUGINS_DIR)                       // 지정되면 절대경로로 정규화한다.
  : path.join(PACKAGES_DIR, "plugins");                         // 기본값: /repo/packages/plugins

/* 주어진 스펙 문자열(spec)을 import() 가능한 "파일 URL" 문자열로 변환한다. */
async function resolvePlugin(spec) {                            // 비동기 함수: 필요 시 파일 검사 수행
  /* 1) 절대경로/상대경로/파일URL은 그대로 처리한다. */
  if (spec.startsWith("./") || spec.startsWith("../")) {        // 상대경로라면
    const url = new URL(spec, import.meta.url);                 // 현재 파일 기준으로 상대경로를 절대 파일 URL로 바꾼다.
    return url.href;                                            // import()가 사용할 href를 반환한다.
  }
  if (spec.startsWith("/") || spec.startsWith("file:")) {       // 절대경로나 file: URL이면
    return spec.startsWith("file:") ? spec : pathToFileURL(spec).href;  // file:면 그대로, 아니면 파일 URL로 변환한다.
  }

  /* 2) "packages/plugins/..." 같은 워크스페이스 별칭을 파일 경로로 치환한다. */
  if (spec.startsWith("packages/plugins/")) {                   // 문제의 케이스를 감지한다.
    const rel = spec.replace(/^packages\/plugins\//, "");       // 앞부분을 떼고 플러그인 상대경로만 남긴다.
    /* 후보 경로들을 나열한다(확장자/엔트리파일 다양성 대응). */
    const candidates = [
      path.join(PLUGINS_DIR, rel, "index.mjs"),                 // 1순위: index.mjs
      path.join(PLUGINS_DIR, rel, "index.js"),                  // 2순위: index.js
      path.join(PLUGINS_DIR, rel + ".mjs"),                     // 3순위: 단일 파일(.mjs)
      path.join(PLUGINS_DIR, rel + ".js"),                      // 4순위: 단일 파일(.js)
      path.join(PLUGINS_DIR, rel, "main.mjs"),                  // 5순위: main.mjs (옵션)
      path.join(PLUGINS_DIR, rel, "main.js"),                   // 6순위: main.js  (옵션)
    ];                                                          // 위 순서는 일반적인 모듈 엔트리를 포괄한다.
    for (const p of candidates) {                               // 각 후보 경로에 대해
      if (fs.existsSync(p)) {                                   // 파일이 실제로 존재한다면
        return pathToFileURL(p).href;                           // 파일 URL로 변환해 반환한다.
      }
    }
    /* 어떤 후보도 존재하지 않으면 친절한 오류 메시지로 실패한다. */
    throw new Error(
      `Plugin "${spec}" not found under workspace plugins dir.\n` +
      `Tried:\n- ${candidates.join("\n- ")}\n` +
      `Resolved PLUGINS_DIR=${PLUGINS_DIR}`
    );                                                          // 사용자가 바로 원인 파악 가능하도록 경로들을 출력한다.
  }

  /* 3) 그 외(진짜 npm 패키지명)는 그대로 반환한다. Node가 node_modules에서 해상도한다. */
  return spec;                                                  // bare specifier는 npm 패키지로 간주해 import(spec) 하도록 그대로 둔다.
}

/* 기존의 플러그인 로더(loadPlugins)를 사용 중이라면, 내부 import(spec)를 import(await resolvePlugin(spec))로 교체한다.
   아래는 drop-in 예시 구현(프로젝트에 이미 구현이 있다면 import 호출부만 교체하면 된다). */
export async function loadPlugins(pluginSpecs = []) {           // plugin 스펙 문자열 배열을 받는다.
  const mods = [];                                              // 로드된 모듈들을 담을 배열
  for (const spec of pluginSpecs) {                             // 각 스펙에 대해
    const resolved = await resolvePlugin(spec);                 // 스펙을 파일 URL 또는 원래 스펙으로 해석한다.
    const mod = await import(resolved);                         // 동적으로 모듈을 로드한다.
    mods.push(mod?.default ?? mod);                             // default export가 있으면 우선 사용하고 없으면 모듈 객체를 넣는다.
  }
  return mods;                                                  // 모든 플러그인을 로드해 반환한다.
}

```


---

## packages/plugins/basic-tokens/packages.json

```json
{
  "name": "@toolkit/basic-tokens",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.mjs"
}

```


---

## packages/plugins/basic-tokens/src/index.mjs

```mjs
export async function register(reg) {
  reg.defineToken("plan", async (ctx) => { ctx.planOnly = true; ctx.tokenFlags.plan = true; });
  reg.defineToken("edit", async (ctx) => { ctx.planOnly = false; ctx.tokenFlags.edit = true; });
  reg.defineToken("dry-run", async (ctx) => { ctx.tokenFlags.dryRun = true; });
  reg.defineToken("fast", async (ctx) => { ctx.preferFast = true; ctx.tokenFlags.fast = true; });
  reg.defineToken("force", async (ctx) => { ctx.tokenFlags.force = true; });
}

```


---

## packages/plugins/cost/packages.json

```json
{
  "name": "@toolkit/cost",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.mjs"
}

```


---

## packages/plugins/cost/src/index.mjs

```mjs
export async function register(reg) {
  reg.defineToken("budget-tokens-1k", async (ctx) => { ctx.tokenFlags.budgetTokens = 1000; });
  reg.defineToken("budget-tokens-5k", async (ctx) => { ctx.tokenFlags.budgetTokens = 5000; });
  reg.defineToken("cooldown-5s", async (ctx) => { ctx.tokenFlags.cooldownSec = 5; });
  reg.defineToken("cooldown-15s", async (ctx) => { ctx.tokenFlags.cooldownSec = 15; });

  reg.addHook("afterLLM", async (ctx) => {
    const budget = ctx.tokenFlags.budgetTokens;
    if (budget && (ctx.usageTotals?.openai)) {
      const used = (ctx.usageTotals.openai.input||0) + (ctx.usageTotals.openai.output||0);
      if (used > budget) {
        ctx.planOnly = true; // Over budget → design-only mode
      }
    }
  });

  reg.addHook("afterAgent", async (ctx) => {
    if (ctx.tokenFlags.cooldownSec) {
      await new Promise(r => setTimeout(r, ctx.tokenFlags.cooldownSec * 1000));
    }
  });

  reg.addHook("beforeLLM", async (ctx) => {
    const plan = ctx.cfg?.providers?.anthropic?.plan || "free";
    if (plan === "pro") {
      ctx.preferFast = false;
    }
  });
}

```


---

## packages/plugins/crawl/packages.json

```json
{
  "name": "@toolkit/crawl",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.mjs"
}

```


---

## packages/plugins/crawl/src/index.mjs

```mjs
import { execSync } from "node:child_process";
export async function register(reg) {
  reg.defineToken("crawl", async (ctx) => { ctx.tokenFlags.crawl = true; });
  reg.addHook("beforeAgent", async (ctx) => {
    if (!ctx.tokenFlags.crawl) return;
    try { execSync("npx --yes playwright install chromium", { stdio: "inherit" }); }
    catch(e) { console.log("Playwright install failed (continuing).", e.message); }
  });
}

```


---

## packages/plugins/hybrid-merge/packages.json

```json
{
  "name": "@toolkit/hybrid-merge",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.mjs"
}

```


---

## packages/plugins/hybrid-merge/src/index.mjs

```mjs
import { execSync } from "node:child_process";

export async function register(reg) {
  reg.defineToken("auto-merge-when-green", async (ctx) => { ctx.tokenFlags.autoMergeWhenGreen = true; });
  reg.defineToken("continue-after-merge", async (ctx) => { ctx.tokenFlags.continueAfterMerge = true; });

  reg.addHook("afterPR", async (ctx) => {
    if (!ctx.prNumber) return;
    const labels = [];
    if (ctx.tokenFlags.autoMergeWhenGreen) labels.push("automation:auto-merge");
    if (ctx.tokenFlags.continueAfterMerge) labels.push("automation:continue");
    if (!labels.length) return;

    try {
      execSync(`gh pr edit ${ctx.prNumber} --add-label "${labels.join(",")}"`, { stdio: "inherit" });
      const note = [
        "### Hybrid merge",
        labels.includes("automation:auto-merge") ? "- Auto-merge: enabled (when all gates are green)" : "",
        labels.includes("automation:continue") ? "- Post-merge continue: enabled" : ""
      ].filter(Boolean).join("\n");
      execSync(`gh pr comment ${ctx.prNumber} --body ${JSON.stringify(note)}`, { stdio: "inherit" });
    } catch (e) {
      console.log("[hybrid-merge] labeling/comment failed:", e.message);
    }
  });
}

```


---

## packages/plugins/self-heal/packages.json

```json
{
  "name": "@toolkit/self-heal",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.mjs"
}

```


---

## packages/plugins/self-heal/src/index.mjs

```mjs
import { execSync } from "node:child_process";
import { writeFileSync } from "node:fs";

function runCmd(cmd) {
  try {
    const out = execSync(cmd, { encoding: "utf-8" });
    return { ok: true, out };
  } catch (e) {
    return { ok: false, out: e.stdout?.toString() || "", err: e.stderr?.toString() || e.message };
  }
}

export async function register(reg) {
  reg.defineToken("diagnose", async (ctx) => { ctx.tokenFlags.diagnose = true; });
  reg.defineToken("autorepair", async (ctx) => { ctx.tokenFlags.autorepair = true; });
  reg.defineToken("test-build", async (ctx) => { ctx.tokenFlags.testBuild = true; });
  reg.defineToken("lint-fix", async (ctx) => { ctx.tokenFlags.lintFix = true; });

  reg.addHook("afterAgent", async (ctx) => {
    if (!ctx.tokenFlags.diagnose && !ctx.tokenFlags.testBuild && !ctx.tokenFlags.lintFix) return;

    const cmds = ctx.pipeline?.commands || {};
    const logs = [];

    if (ctx.tokenFlags.lintFix && cmds.lint_fix) {
      const r = runCmd(cmds.lint_fix);
      logs.push({ stage: "lint-fix", ok: r.ok, out: r.out, err: r.err });
    }

    if (ctx.tokenFlags.testBuild && cmds.test) {
      const r = runCmd(cmds.test);
      logs.push({ stage: "test", ok: r.ok, out: r.out, err: r.err });
    }

    if (ctx.tokenFlags.testBuild && cmds.build) {
      const r = runCmd(cmds.build);
      logs.push({ stage: "build", ok: r.ok, out: r.out, err: r.err });
    }

    ctx.diagnostics.last = { logs };

    const failed = logs.find(l => l.ok === false);
    if (failed && ctx.tokenFlags.autorepair) {
      const truncated = (failed.err || failed.out || "").slice(-5000);
      const hint = [
        "[DIAGNOSTICS]",
        `- Stage: ${failed.stage}`,
        `- Error (tail):`,
        "```",
        truncated,
        "```",
        "",
        "Please patch the repository to resolve this failure.",
        "- Keep changes minimal and explainable.",
        "- Update or create tests if needed.",
        "- After patching, re-run the failing stage locally in the next step."
      ].join("\n");
      ctx.agentPrompt = (ctx.agentPrompt + "\n\n" + hint).slice(-30000);
    }

    try {
      writeFileSync(".github/auto/diagnostics-last.json", JSON.stringify({ when: new Date().toISOString(), logs }, null, 2), "utf8");
    } catch {}
  });
}

```
