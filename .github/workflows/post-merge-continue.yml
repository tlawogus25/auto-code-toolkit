# name: 워크플로의 사람이 읽는 이름을 정의합니다.
name: post-merge-continue  # 닫힘 후 후속 이슈를 생성하고 auto-code를 디스패치하는 워크플로

# on: 어떤 이벤트로 이 워크플로가 실행될지 정의합니다.
on:                         # 트리거 정의 시작
  pull_request:             # PR 관련 이벤트를 사용합니다.
    types: [closed]         # PR이 닫힐 때(머지 포함) 실행되도록 지정합니다.
  workflow_dispatch:        # 수동 디스패치를 허용해 백필 실행 경로를 만듭니다.
    inputs:                 # 디스패치 시 전달할 입력값들을 정의합니다.
      pr:                   # 병합된 PR 번호를 받기 위한 입력입니다.
        description: "Merged PR number to continue from"  # 입력 설명입니다.
        required: false      # 입력은 선택 사항입니다(없으면 PR 이벤트 페이로드를 사용).
        type: string         # 문자열 타입으로 지정합니다.

# permissions: 이 워크플로에서 사용할 권한 범위를 최소 권한 원칙에 맞추어 선언합니다.
permissions:                 # 권한 블록 시작
  contents: read             # 리포 콘텐츠를 읽을 수 있는 권한입니다.
  pull-requests: read        # PR 정보를 읽을 수 있는 권한입니다.
  issues: write              # 후속 이슈를 생성/라벨링하기 위한 권한입니다.
  actions: write             # 워크플로 디스패치 등을 수행하기 위한 권한입니다.

# jobs: 실제로 실행할 작업(잡)들을 정의합니다.
jobs:                        # 잡 목록 시작
  continue:                  # 잡 이름을 정의합니다.
    # if: 잡 실행 조건을 단순화합니다(레이스 방지).
    # 1) PR 이벤트면 merged == true 일 때만 실행합니다.
    # 2) 수동 디스패치(workflow_dispatch)면 조건 없이 실행합니다.
    if: >-
      ${{
        (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
        || (github.event_name == 'workflow_dispatch')
      }}
    runs-on: ubuntu-latest   # GitHub 호스트 러너(우분투 최신)를 사용합니다.

    steps:                   # 스텝 목록을 정의합니다.

      - name: Resolve PR context                               # 어떤 PR을 대상으로 할지 결정합니다.
        id: ctx                                                 # 다음 스텝에서 참조할 ID입니다.
        uses: actions/github-script@v7                          # GitHub Script 액션을 사용합니다.
        with:                                                   # 액션 입력을 설정합니다.
          script: |                                             # Node.js(JavaScript) 스크립트입니다.
            // 이벤트가 pull_request면 페이로드에서 PR 번호를 읽고,                 // 동작 개요 주석
            // 수동 디스패치면 입력값(inputs.pr)을 사용합니다.                       // 입력 처리 주석
            const prFromPayload = (context.eventName === 'pull_request')
              ? context.payload.pull_request?.number
              : null;                                           // PR 이벤트일 때의 번호입니다.
            const prFromInput = (context.eventName === 'workflow_dispatch')
              ? (core.getInput('pr') || '')
              : '';                                             // 디스패치 입력으로 받은 번호입니다.
            const prNumber = prFromPayload ?? (prFromInput ? parseInt(prFromInput, 10) : NaN);  // 최종 PR 번호입니다.
            if (!prNumber || Number.isNaN(prNumber)) {          // 유효한 PR 번호인지 검사합니다.
              core.setFailed('PR number is missing.');          // 번호가 없으면 워크플로를 실패로 처리합니다.
              return;                                           // 실행을 중단합니다.
            }
            core.setOutput('pr', String(prNumber));             // 이후 스텝에서 사용할 출력값으로 저장합니다.

      - name: Check live label "automation:continue"            # 실시간으로 PR 라벨을 조회합니다.
        id: lab                                                 # 다음 스텝에서 참조할 ID입니다.
        uses: actions/github-script@v7                          # GitHub Script 액션을 사용합니다.
        env:                                                    # 이전 스텝의 출력을 환경변수로 전달합니다.
          PR: ${{ steps.ctx.outputs.pr }}                       # 확인 대상 PR 번호입니다.
        with:                                                   # 액션 입력을 설정합니다.
          script: |                                             # Node.js(JavaScript) 스크립트입니다.
            // PR의 라벨을 실시간 REST API로 조회해 레이스를 회피합니다.              // 접근 방식 설명
            const pr = Number(process.env.PR || '0');           // 환경변수에서 PR 번호를 읽습니다.
            const { owner, repo } = context.repo;               // 리포 식별자(소유자/리포)를 얻습니다.
            const labels = await github.paginate(               // 모든 라벨 페이지를 순회합니다.
              github.rest.issues.listLabelsOnIssue,             // 이슈(=PR)의 라벨 API입니다.
              { owner, repo, issue_number: pr, per_page: 100 }  // PR 번호와 페이지 크기를 지정합니다.
            );
            const has = labels.some(l => l.name === 'automation:continue');  // 대상 라벨 포함 여부입니다.
            core.setOutput('has', String(has));                 // 다음 스텝 분기를 위한 출력을 저장합니다.
            if (!has) {                                         // 라벨이 없다면
              core.info('automation:continue label not found. Skipping follow-up.');  // 스킵 로그를 남깁니다.
            }

      - name: Create follow-up issue with improvements (LLM) or fallback  # 후속 이슈를 생성합니다.
        if: steps.lab.outputs.has == 'true'                     # 대상 라벨이 있을 때만 실행합니다.
        id: followup                                            # 다음 스텝에서 참조할 ID입니다.
        uses: actions/github-script@v7                          # GitHub Script 액션을 사용합니다.
        env:                                                    # LLM/프롬프트용 환경변수를 주입합니다.
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}         # OpenAI 키(없으면 폴백 경로 사용).
          AUTO_CONTINUE_LINE: ${{ vars.AUTO_CONTINUE_LINE }}    # 기본 /auto 프롬프트 한 줄입니다.
          PR: ${{ steps.ctx.outputs.pr }}                       # 작업 대상 PR 번호입니다.
        with:                                                   # 액션 입력을 설정합니다.
          script: |                                             # Node.js(JavaScript) 스크립트입니다.
            // ─────────────────────────────────────────────────────────────────────────────────── // 섹션 안내 주석
            // 0) 컨텍스트/기본 프롬프트 구성                                                        // 단계 설명 주석
            const prNumber = Number(process.env.PR || '0');     // 대상 PR 번호를 로드합니다.
            const { owner, repo } = context.repo;               // 리포 식별자를 로드합니다.
            const autoLine = (process.env.AUTO_CONTINUE_LINE || '/auto edit long diagnose autorepair test-build lint-fix cooldown-15s time-120m steps-2').trim();  // 기본 /auto 라인입니다.

            // 1) 프롬프트 블록 수집(코멘트 → 본문 순)                                               // 단계 설명 주석
            const comments = await github.paginate(             // PR 코멘트를 모두 조회합니다.
              github.rest.issues.listComments,                  // 이슈 코멘트 API입니다.
              { owner, repo, issue_number: prNumber, per_page: 100 }  // PR 번호를 지정합니다.
            );
            let promptBlock = null;                             // 프롬프트 블록 초기값입니다.
            for (const c of [...comments].reverse()) {          // 최신 코멘트부터 검사합니다.
              const body = c.body || '';                        // 코멘트 본문을 읽습니다.
              if (body.includes('# Original Prompt') || body.includes('## Last Agent Prompt')) {  // 키워드를 찾습니다.
                promptBlock = body; break;                      // 찾으면 채택하고 종료합니다.
              }
            }
            if (!promptBlock) {                                 // 코멘트에서 못 찾으면
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });  // PR 본문을 조회합니다.
              const b = pr?.data?.body || '';                  // 본문을 얻습니다.
              if (b.includes('## Prompt')) promptBlock = b;    // 키워드가 있으면 채택합니다.
            }
            if (!promptBlock) {                                 // 그래도 없으면
              promptBlock = '_No previous prompt could be retrieved from PR comments/body._';  // 기본 안내로 대체합니다.
            }

            // 2) 변경 파일/패치 요약                                                                // 단계 설명 주석
            const files = await github.paginate(                // PR 변경 파일을 모두 조회합니다.
              github.rest.pulls.listFiles,                      // 변경 파일 API입니다.
              { owner, repo, pull_number: prNumber, per_page: 100 }  // PR 번호를 지정합니다.
            );
            const changed = files.map(f => `- ${f.filename} (${f.status})`).join('\n');  // 변경 파일 요약 문자열입니다.
            const patches = files.map(f => `# ${f.filename}\n${f.patch || ''}`).join('\n\n');  // 패치 텍스트를 구성합니다.
            const patchTruncLimit = 60000;                      // 과도한 길이를 방지하는 한도입니다.
            const patchText = patches.length > patchTruncLimit
              ? patches.slice(0, patchTruncLimit) + '\n\n_(patch truncated)_'  // 길면 잘라냅니다.
              : patches;                                        // 아니면 원본을 사용합니다.

            // 3) LLM 호출(있으면) → 엄격 JSON 파싱 → 실패 시 폴백                                 // 단계 설명 주석
            let llmResult = { complete: false, suggestions: [] };  // 기본값을 설정합니다.
            const system = 'You are a senior code reviewer. Analyze merged PR changes and propose concrete, high-impact follow-up improvements only if truly needed. Otherwise mark complete=true.';  // 시스템 프롬프트입니다.
            const userPrompt = [
              '## PR number', String(prNumber),
              '## Changed files', changed || '(none)',
              '## Prompt context from PR comments/body', promptBlock || '',
              '## Patches (unified)', patchText || '(none)',
              '',
              '### TASK',
              '{ "complete": boolean, "suggestions": [ { "title": string, "why": string, "how": string, "files": string[] } ] }',
              'Rules: Only JSON. Prefer small, incremental, measurable improvements.'
            ].join('\n');                                       // 사용자 프롬프트를 구성합니다.

            async function callOpenAI() {                       // OpenAI 호출 헬퍼입니다.
              const key = process.env.OPENAI_API_KEY;           // 키를 읽습니다(없을 수 있습니다).
              if (!key) return null;                            // 키가 없으면 건너뜁니다.
              const payload = {                                 // Chat Completions 페이로드입니다.
                model: 'gpt-4o-mini',                           // 경량/비용 효율 모델 예시입니다.
                messages: [                                     // 대화 메시지 배열입니다.
                  { role: 'system', content: system },          // 시스템 역할입니다.
                  { role: 'user', content: userPrompt }         // 사용자 입력입니다.
                ],
                temperature: 0.2                                // 결정적 출력을 유도합니다.
              };
              const res = await fetch('https://api.openai.com/v1/chat/completions', {  // 엔드포인트입니다.
                method: 'POST',                                 // HTTP 메서드입니다.
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },  // 헤더입니다.
                body: JSON.stringify(payload)                   // 본문입니다.
              });
              if (!res.ok) return null;                         // 실패 시 null을 반환합니다.
              const data = await res.json();                    // JSON을 파싱합니다.
              const text = data?.choices?.[0]?.message?.content || '';  // 응답 텍스트를 추출합니다.
              try { return JSON.parse(text); } catch { return null; }   // JSON으로 파싱을 시도합니다.
            }

            try {                                               // LLM 호출을 시도합니다.
              const out = await callOpenAI();                   // 결과를 받습니다.
              if (out && typeof out.complete === 'boolean' && Array.isArray(out.suggestions)) {
                llmResult = out;                                // 유효하면 결과를 채택합니다.
              }
            } catch (e) {                                       // 예외가 발생하면
              core.warning('LLM analyze failed; falling back: ' + (e?.message || e));  // 경고를 남깁니다.
            }

            // 4) 완료 판정이면 이슈 생략 + 완료 표식을 남기고 종료합니다.
            if (llmResult.complete === true || (Array.isArray(llmResult.suggestions) && llmResult.suggestions.length === 0)) {
              core.info('No meaningful improvements found by LLM. Skipping follow-up issue.');  // 안내 로그입니다.
              const completeLabel = 'automation:complete';      // 완료 라벨 이름입니다.
              try {                                             // 라벨 존재 확인/생성을 시도합니다.
                try { await github.rest.issues.getLabel({ owner, repo, name: completeLabel }); }  // 존재 확인입니다.
                catch {
                  try {                                         // 없으면 생성합니다.
                    await github.rest.issues.createLabel({
                      owner, repo, name: completeLabel, color: '0E8A16',
                      description: 'Auto-code cycle determined complete; no follow-up issue created.'
                    });
                  } catch (e) { core.warning('createLabel failed (ignored): ' + (e?.message || e)); }  // 실패 무시입니다.
                }
                await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [completeLabel] });  // 라벨을 부착합니다.
              } catch (e) { core.warning('addLabels(automation:complete) failed (ignored): ' + (e?.message || e)); }   // 실패 무시입니다.
              try {                                            // PR에 완료 코멘트를 남깁니다.
                await github.rest.issues.createComment({
                  owner, repo, issue_number: prNumber,
                  body: ':white_check_mark: **Auto-code:** LLM 판단으로 추가 개선이 없어 *후속 이슈를 생성하지 않았습니다*. 사이클을 종료합니다.'
                });
              } catch (e) { core.warning('createComment completion note failed (ignored): ' + (e?.message || e)); }  // 실패 무시입니다.
              core.setOutput('skip', 'true');                   // 이후 디스패치를 건너뛰도록 출력합니다.
              core.setOutput('auto_line', autoLine);            // 참고용으로 auto_line을 전달합니다.
              core.setOutput('marked_complete', 'true');        // 완료 표식을 출력합니다.
              return;                                           // 스텝을 종료합니다.
            }

            // 5) 후속 이슈 본문을 구성하고 생성합니다.
            const suggestionsMd = (llmResult.suggestions || []).map((s, i) => {
              const files = Array.isArray(s.files) ? s.files.map(f => ` \`${f}\``).join(',') : '';  // 파일 리스트를 문자열로 만듭니다.
              return `### ${i + 1}. ${s.title}\n- Why: ${s.why}\n- How: ${s.how}\n- Files:${files ? ' ' + files : ' (n/a)'}`;  // 항목을 마크다운으로 구성합니다.
            }).join('\n\n');                                   // 항목들을 합칩니다.
            const chainMarker = `<!-- chain:pr${prNumber}->issue? run:${context.runId} -->`;  // 체인 추적용 마커입니다.
            const body = [
              autoLine,                                        // 다음 행동을 나타내는 /auto 한 줄입니다.
              '',
              '자동 생성된 후속 작업입니다. 아래 개선 항목을 우선 처리하세요:',  // 안내 문구입니다.
              '',
              suggestionsMd || '- (generator returned empty)', // 제안 항목이 없으면 기본 문구를 넣습니다.
              '',
              chainMarker,                                     // 체인 추적 마커를 포함합니다.
              '',
              '[Context from previous run]',                   // 컨텍스트 제목입니다.
              '',
              promptBlock                                      // 수집된 프롬프트 블록을 첨부합니다.
            ].join('\n');                                      // 본문을 합칩니다.
            const title = `Continue: follow-up tasks after PR #${prNumber}`;  // 이슈 제목입니다.
            const issue = await github.rest.issues.create({     // 이슈를 생성합니다.
              owner, repo, title, body, labels: ['automation:run', 'automation:generated']  // 라벨을 부착합니다.
            });
            await github.rest.issues.createComment({            // 체인 추적 코멘트를 남깁니다.
              owner, repo, issue_number: issue.data.number,
              body: `Follow-up for PR #${prNumber}\n\n${chainMarker.replace('issue?', 'issue' + issue.data.number)}`
            });
            core.setOutput('skip', 'false');                    // 후속 디스패치를 수행하도록 출력합니다.
            core.setOutput('issue_number', String(issue.data.number));  // 생성된 이슈 번호를 출력합니다.
            core.setOutput('auto_line', autoLine);              // 디스패치에 사용할 /auto 라인을 출력합니다.

      - name: Trigger auto-code via workflow_dispatch           # auto-code 워크플로를 명시적으로 디스패치합니다.
        if: steps.followup.outputs.skip != 'true'              # 후속 이슈를 만든 경우에만 실행합니다.
        uses: actions/github-script@v7                         # GitHub Script 액션을 사용합니다.
        env:                                                   # followup 스텝의 출력을 환경변수로 전달합니다.
          AUTO_LINE: ${{ steps.followup.outputs.auto_line }}   # /auto 한 줄입니다.
        with:                                                  # 액션 입력을 설정합니다.
          script: |                                            # Node.js(JavaScript) 스크립트입니다.
            const { owner, repo } = context.repo;              // 리포 식별자입니다.
            const defaultRef = context.payload?.repository?.default_branch || 'main';  // 기본 브랜치를 얻습니다.
            const autoLine = (process.env.AUTO_LINE || '/auto ping').trim();  // 디스패치 바디를 결정합니다.
            await github.rest.actions.createWorkflowDispatch({  // 워크플로 디스패치를 호출합니다.
              owner, repo,                                     // 리포 식별자입니다.
              workflow_id: '.github/workflows/auto-code.yml',  // 대상 워크플로 파일 경로입니다.
              ref: defaultRef,                                 // 디스패치 기준 ref(브랜치)입니다.
              inputs: { body: autoLine }                       // 입력 파라미터를 전달합니다.
            });                                                // 디스패치를 수행합니다.
