name: post-merge-continue
on:
  pull_request:
    types: [closed]

permissions:
  contents: read
  pull-requests: read
  issues: write
  actions: write

jobs:
  continue:
    if: ${{ github.event.pull_request.merged == true && contains(github.event.pull_request.labels.*.name, 'automation:continue') }}
    runs-on: ubuntu-latest
    steps:
      - name: Create follow-up issue with improvements (LLM) or skip if complete
        id: followup
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          AUTO_CONTINUE_LINE: ${{ vars.AUTO_CONTINUE_LINE }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;

            // 0) 기본 /auto 한 줄
            const autoLine =
              (process.env.AUTO_CONTINUE_LINE && process.env.AUTO_CONTINUE_LINE.trim()) ||
              "/auto edit long diagnose autorepair test-build lint-fix cooldown-15s time-120m steps-2";

            // 1) PR 코멘트(프롬프트 블록) 수집
            const comments = await github.paginate(
              github.rest.issues.listComments,
              { owner, repo, issue_number: pr.number, per_page: 100 }
            );
            let promptBlock = null;
            for (const c of comments.reverse()) {
              const body = c.body || "";
              if (body.includes("# Original Prompt") || body.includes("## Last Agent Prompt")) {
                promptBlock = body; break;
              }
            }
            if (!promptBlock) {
              const b = pr.body || "";
              if (b.includes("## Prompt")) promptBlock = b;
            }
            if (!promptBlock) {
              promptBlock = "_No previous prompt could be retrieved from PR comments/body._";
            }

            // 2) 변경 파일 + 패치 요약
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number: pr.number, per_page: 100 }
            );
            const changed = files.map(f => `- ${f.filename} (${f.status})`).join("\n");
            const patches = files.map(f => `# ${f.filename}\n${f.patch || ""}`).join("\n\n");
            const patchTruncLimit = 60000; // 과도한 길이 방지
            const patchText = patches.length > patchTruncLimit
              ? patches.slice(0, patchTruncLimit) + "\n\n_(patch truncated)_"
              : patches;

            // 3) LLM 호출(있으면). 없으면 폴백(무조건 이슈 생성)
            let llmResult = { complete: false, suggestions: [] };
            const system = "You are a senior code reviewer. Analyze merged PR changes and propose concrete, high-impact follow-up improvements only if truly needed. Otherwise mark complete=true.";
            const userPrompt = [
              "## PR title", pr.title || "",
              "## PR body", pr.body || "",
              "## Changed files", changed || "(none)",
              "## Prompt context from PR comments/body", promptBlock || "",
              "## Patches (unified, per-file)", patchText || "(none)",
              "",
              "### TASK",
              "Return STRICT JSON with fields:",
              "{",
              '  "complete": boolean,',
              '  "suggestions": [',
              '    {"title": string, "why": string, "how": string, "files": string[] }',
              "  ]",
              "}",
              "",
              "Rules:",
              "- Only propose suggestions that measurably improve quality, correctness, tests, DX, or performance.",
              "- If no meaningful work remains, set complete=true and suggestions=[].",
              "- Prefer small, incremental changes over broad refactors.",
              "- Do NOT output markdown, ONLY JSON."
            ].join("\n");

            async function callOpenAI() {
              const key = process.env.OPENAI_API_KEY;
              if (!key) return null;
              const payload = {
                model: "gpt-4o-mini",
                messages: [
                  { role: "system", content: system },
                  { role: "user", content: userPrompt }
                ],
                temperature: 0.2
              };
              const res = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
                body: JSON.stringify(payload)
              });
              if (!res.ok) return null;
              const data = await res.json();
              const text = data?.choices?.[0]?.message?.content || "";
              try { return JSON.parse(text); } catch { return null; }
            }

            try {
              const out = await callOpenAI();
              if (out && typeof out.complete === "boolean" && Array.isArray(out.suggestions)) {
                llmResult = out;
              }
            } catch (e) {
              core.warning("LLM analyze failed; falling back: " + (e.message || e));
            }

            // 4) complete=true면: 후속 이슈 생략 + 완료 표기(라벨 + 코멘트) 후 종료
            if (llmResult.complete === true || (Array.isArray(llmResult.suggestions) && llmResult.suggestions.length === 0)) {
              core.info("No meaningful improvements found by LLM. Skipping follow-up issue.");

              // 라벨 준비/부착: automation:complete
              const completeLabel = "automation:complete";
              try {
                // 라벨이 없을 수 있으므로 존재 확인 후 생성 시도
                try {
                  await github.rest.issues.getLabel({ owner, repo, name: completeLabel });
                } catch {
                  try {
                    await github.rest.issues.createLabel({
                      owner, repo, name: completeLabel,
                      color: "0E8A16",
                      description: "Auto-code cycle determined complete; no follow-up issue created."
                    });
                  } catch (e) {
                    core.warning("createLabel failed (ignored): " + (e.message || e));
                  }
                }
                await github.rest.issues.addLabels({
                  owner, repo, issue_number: pr.number, labels: [completeLabel]
                });
              } catch (e) {
                core.warning("addLabels(automation:complete) failed (ignored): " + (e.message || e));
              }

              // 완료 코멘트
              try {
                await github.rest.issues.createComment({
                  owner, repo, issue_number: pr.number,
                  body: ":white_check_mark: **Auto-code:** LLM 판단으로 추가 개선이 없어 *후속 이슈를 생성하지 않았습니다*. 사이클을 여기서 종료합니다."
                });
              } catch (e) {
                core.warning("createComment completion note failed (ignored): " + (e.message || e));
              }

              core.setOutput("skip", "true");
              core.setOutput("auto_line", autoLine);
              core.setOutput("marked_complete", "true");
              return;
            }

            // 5) 후속 이슈 템플릿 구성
            const m = (pr.body||"").match(/Source-Issue:\s*#(\d+)/i);
            const sourceIssue = m ? Number(m[1]) : null;
            const chainMarker = `<!-- chain:pr${pr.number}->issue? source:${sourceIssue||'n/a'} run:${context.runId} -->`;

            const suggestionsMd = (llmResult.suggestions || []).map((s, i) => {
              const files = Array.isArray(s.files) ? s.files.map(f=>` \`${f}\``).join(",") : "";
              return `### ${i+1}. ${s.title}\n- Why: ${s.why}\n- How: ${s.how}\n- Files:${files ? " " + files : " (n/a)"}`;
            }).join("\n\n");

            const body = [
              autoLine,
              "",
              "자동 생성된 후속 작업입니다. 아래 개선 항목을 우선 처리하세요:",
              "",
              suggestionsMd || "- (generator returned empty)",
              "",
              chainMarker,
              "",
              "[Context from previous run]",
              "",
              promptBlock
            ].join("\n");

            const title = `Continue: follow-up tasks after PR #${pr.number}`;
            const issue = await github.rest.issues.create({
              owner, repo, title, body, labels: ["automation:run","automation:generated"]
            });

            await github.rest.issues.createComment({
              owner, repo, issue_number: issue.data.number,
              body: `Follow-up for PR #${pr.number}\n\n${chainMarker.replace('issue?', 'issue'+issue.data.number)}`
            });

            core.setOutput("skip", "false");
            core.setOutput("issue_number", String(issue.data.number));
            core.setOutput("auto_line", autoLine);

      - name: Trigger auto-code via workflow_dispatch
        if: steps.followup.outputs.skip != 'true'
        uses: actions/github-script@v7
        env:
          AUTO_LINE: ${{ steps.followup.outputs.auto_line }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const ref = context.payload.pull_request?.base?.ref || (context.payload.repository?.default_branch ?? "main");
            const autoLine = (process.env.AUTO_LINE && process.env.AUTO_LINE.trim()) || "/auto ping";
            await github.rest.actions.createWorkflowDispatch({
              owner, repo,
              workflow_id: ".github/workflows/auto-code.yml",
              ref,
              inputs: { body: autoLine }
            });
