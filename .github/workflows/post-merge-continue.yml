name: post-merge-continue  # 닫힘 후 후속 이슈 생성/디스패치

on:
  pull_request:
    types: [closed]
  workflow_dispatch:
    inputs:
      pr:
        description: "Merged PR number to continue from"
        required: false
        type: string

permissions:
  contents: read
  pull-requests: read
  issues: write
  actions: write

jobs:
  continue:
    if: >-
      ${{
        (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
        || (github.event_name == 'workflow_dispatch')
      }}
    runs-on: ubuntu-latest

    steps:
      - name: Resolve PR context
        id: ctx
        uses: actions/github-script@v7
        with:
          script: |
            const prFromPayload = (context.eventName === 'pull_request')
              ? context.payload.pull_request?.number : null;
            const prFromInput = (context.eventName === 'workflow_dispatch')
              ? (core.getInput('pr') || '') : '';
            const prNumber = prFromPayload ?? (prFromInput ? parseInt(prFromInput, 10) : NaN);
            if (!prNumber || Number.isNaN(prNumber)) { core.setFailed('PR number is missing.'); return; }
            core.setOutput('pr', String(prNumber));

      - name: Decide if we should continue (label OR tokens)
        id: gate
        uses: actions/github-script@v7
        env:
          PR: ${{ steps.ctx.outputs.pr }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr = Number(process.env.PR || '0');

            // 1) 라벨 실시간 확인
            const labels = await github.paginate(
              github.rest.issues.listLabelsOnIssue,
              { owner, repo, issue_number: pr, per_page: 100 }
            );
            const hasLabel = labels.some(l => l.name === 'automation:continue');

            // 2) PR 본문에서 토큰(continue-after-merge) 확인
            const prData = (await github.rest.pulls.get({ owner, repo, pull_number: pr })).data;
            const body = String(prData.body || '');
            const hasToken = /\bcontinue-after-merge\b/i.test(body) || /\bTokens:\s*.*\bcontinue-after-merge\b/i.test(body);

            // 3) (옵션) 자동 생성 브랜치만 대상 (필요 없으면 아래 줄 주석처리)
            const isAutoBranch = String(prData.head?.ref || '').startsWith('auto/');

            const should = (hasLabel || hasToken) && isAutoBranch;
            core.info(`hasLabel=${hasLabel} hasToken=${hasToken} isAutoBranch=${isAutoBranch} => shouldContinue=${should}`);
            core.setOutput('go', String(should));

      - name: Create follow-up issue (LLM-assisted) or skip
        if: steps.gate.outputs.go == 'true'
        id: followup
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PR: ${{ steps.ctx.outputs.pr }}
          AUTO_CONTINUE_LINE: ${{ vars.AUTO_CONTINUE_LINE }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = Number(process.env.PR || '0');
            const autoLine = (process.env.AUTO_CONTINUE_LINE || '/auto edit long diagnose autorepair test-build lint-fix cooldown-15s time-120m steps-2').trim();

            // 최근 코멘트/본문에서 프롬프트 블록 줍기
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: prNumber, per_page: 100 });
            let promptBlock = null;
            for (const c of [...comments].reverse()) {
              const body = c.body || '';
              if (body.includes('# Original Prompt') || body.includes('## Last Agent Prompt')) { promptBlock = body; break; }
            }
            if (!promptBlock) {
              const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              const b = pr?.data?.body || '';
              if (b.includes('## Prompt')) promptBlock = b;
            }
            if (!promptBlock) promptBlock = '_No previous prompt found._';

            // 변경 파일 요약
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber, per_page: 100 });
            const changed = files.map(f => `- ${f.filename} (${f.status})`).join('\n');

            // (간단) LLM 없음 폴백: 무조건 Follow-up 권장 템플릿
            const chainMarker = `<!-- chain:pr${prNumber}->issue? run:${context.runId} -->`;
            const body = [
              autoLine,
              '',
              '자동 후속 작업입니다. 아래 변경 내역을 바탕으로 다음 스텝을 진행하세요.',
              '',
              '### Changed files',
              changed || '(none)',
              '',
              chainMarker,
              '',
              '[Context from previous run]',
              '',
              promptBlock
            ].join('\n');

            const title = `Continue: follow-up after PR #${prNumber}`;
            const issue = await github.rest.issues.create({
              owner, repo, title, body, labels: ['automation:run', 'automation:generated']
            });

            await github.rest.issues.createComment({
              owner, repo, issue_number: issue.data.number,
              body: `Follow-up for PR #${prNumber}\n\n${chainMarker.replace('issue?', 'issue' + issue.data.number)}`
            });

            core.setOutput('issue_number', String(issue.data.number));
            core.setOutput('auto_line', autoLine);

      - name: Trigger auto-code (workflow_dispatch)
        if: steps.gate.outputs.go == 'true'
        uses: actions/github-script@v7
        env:
          AUTO_LINE: ${{ steps.followup.outputs.auto_line }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const ref = context.payload?.repository?.default_branch || 'main';
            const body = (process.env.AUTO_LINE || '/auto ping').trim();
            await github.rest.actions.createWorkflowDispatch({
              owner, repo,
              workflow_id: '.github/workflows/auto-code.yml',
              ref, inputs: { body }
            })

      - name: Note when skipping follow-up
        if: steps.gate.outputs.go != 'true'
        run: echo "No automation:continue label nor continue-after-merge token (or not an auto/* branch). Skipping."
